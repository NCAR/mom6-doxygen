<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DART CAM-SE: /Users/hkershaw/DART/Doxygen/DART/assimilation_code/modules/io/direct_netcdf_mod.f90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DART CAM-SE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4b8c547e68dcddf016c38a1b08f5c7a9.html">DART</a></li><li class="navelem"><a class="el" href="dir_45bc59af759ed40ec308edf679618634.html">assimilation_code</a></li><li class="navelem"><a class="el" href="dir_b72b743c828fcd5d2c7dc1877007622f.html">modules</a></li><li class="navelem"><a class="el" href="dir_e3f6fc846e386e573b9ff2f81e140205.html">io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Modules</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">direct_netcdf_mod.f90 File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="direct__netcdf__mod_8f90_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:namespacedirect__netcdf__mod" id="r_namespacedirect__netcdf__mod"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedirect__netcdf__mod.html">direct_netcdf_mod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ga5e6a92968fe0fa12010bff633ab92549" id="r_ga5e6a92968fe0fa12010bff633ab92549"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga5e6a92968fe0fa12010bff633ab92549">direct_netcdf_mod::read_transpose</a> (state_ens_handle, name_handle, domain, dart_index, read_single_vars)</td></tr>
<tr class="memdesc:ga5e6a92968fe0fa12010bff633ab92549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and transpose variables in cyclic-cyclic distribution (round robbin)  <br /></td></tr>
<tr class="separator:ga5e6a92968fe0fa12010bff633ab92549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca56c81dfed34ffca506790ad794e1c" id="r_ga8ca56c81dfed34ffca506790ad794e1c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga8ca56c81dfed34ffca506790ad794e1c">direct_netcdf_mod::transpose_write</a> (state_ens_handle, name_handle, domain, dart_index, write_single_vars, write_single_precision)</td></tr>
<tr class="memdesc:ga8ca56c81dfed34ffca506790ad794e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This code transposes and writes out the state vector copies This can either be done on a single task or with multiple tasks.  <br /></td></tr>
<tr class="separator:ga8ca56c81dfed34ffca506790ad794e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga811379f67b7a78e7cbfab32f80b54b8c" id="r_ga811379f67b7a78e7cbfab32f80b54b8c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga811379f67b7a78e7cbfab32f80b54b8c">direct_netcdf_mod::initialize_single_file_io</a> (ens_handle, file_handle)</td></tr>
<tr class="memdesc:ga811379f67b7a78e7cbfab32f80b54b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a template file for single file io Calls the model for any model specific attributes to be written.  <br /></td></tr>
<tr class="separator:ga811379f67b7a78e7cbfab32f80b54b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da57561c4275530367b53a116303f9f" id="r_ga5da57561c4275530367b53a116303f9f"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga5da57561c4275530367b53a116303f9f">direct_netcdf_mod::finalize_single_file_io</a> (file_handle)</td></tr>
<tr class="separator:ga5da57561c4275530367b53a116303f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bde9358fa6fadc774d471d0bec36553" id="r_ga1bde9358fa6fadc774d471d0bec36553"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga1bde9358fa6fadc774d471d0bec36553">direct_netcdf_mod::read_single_file</a> (state_ens_handle, file_handle, use_time_from_file, mtime, pert_from_single_copy)</td></tr>
<tr class="memdesc:ga1bde9358fa6fadc774d471d0bec36553"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a single netcdf file containing all of the members and possibly inflation information  <br /></td></tr>
<tr class="separator:ga1bde9358fa6fadc774d471d0bec36553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e97fc6bd08a2af8be0d542ecc56a58" id="r_ga53e97fc6bd08a2af8be0d542ecc56a58"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga53e97fc6bd08a2af8be0d542ecc56a58">direct_netcdf_mod::write_single_file</a> (ens_handle, file_handle)</td></tr>
<tr class="memdesc:ga53e97fc6bd08a2af8be0d542ecc56a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">write all variable to a single file including all member, and optionally inflation, mean, sd  <br /></td></tr>
<tr class="separator:ga53e97fc6bd08a2af8be0d542ecc56a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db4441591f610b3e2c4d06480c28535" id="r_ga4db4441591f610b3e2c4d06480c28535"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga4db4441591f610b3e2c4d06480c28535">direct_netcdf_mod::write_augmented_state</a> (ens_handle, file_handle)</td></tr>
<tr class="memdesc:ga4db4441591f610b3e2c4d06480c28535"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert the mean and sd into the input file if the user requests this assumes that the files has already been closed and the variables read in.  <br /></td></tr>
<tr class="separator:ga4db4441591f610b3e2c4d06480c28535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff418907b25b36edeaf6a7bae9f42a2" id="r_ga5ff418907b25b36edeaf6a7bae9f42a2"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga5ff418907b25b36edeaf6a7bae9f42a2">direct_netcdf_mod::read_variables</a> (ncfile_in, var_block, start_var, end_var, domain)</td></tr>
<tr class="memdesc:ga5ff418907b25b36edeaf6a7bae9f42a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in variables from start_var to end_var Read the latest time slice in the file.  <br /></td></tr>
<tr class="separator:ga5ff418907b25b36edeaf6a7bae9f42a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd1c0ced6a496672242e6b11e230b18" id="r_ga5bd1c0ced6a496672242e6b11e230b18"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga5bd1c0ced6a496672242e6b11e230b18">direct_netcdf_mod::read_transpose_single_task</a> (state_ens_handle, name_handle, domain, dart_index)</td></tr>
<tr class="memdesc:ga5bd1c0ced6a496672242e6b11e230b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single processor version of read_transpose. Reads ens_size whole vectors from netcdf files and fills up a row of copies for each file.  <br /></td></tr>
<tr class="separator:ga5bd1c0ced6a496672242e6b11e230b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0dc19e06b1c54e04d3bd0921f674a1" id="r_ga5a0dc19e06b1c54e04d3bd0921f674a1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga5a0dc19e06b1c54e04d3bd0921f674a1">direct_netcdf_mod::transpose_write_single_task</a> (state_ens_handle, name_handle, domain, dart_index, write_single_precision)</td></tr>
<tr class="memdesc:ga5a0dc19e06b1c54e04d3bd0921f674a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single processor version of transpose write. Takes copies array one row at a time and writes copy to a netcdf file.  <br /></td></tr>
<tr class="separator:ga5a0dc19e06b1c54e04d3bd0921f674a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ddfc9953eb0e009c773f60a75a61f78" id="r_ga4ddfc9953eb0e009c773f60a75a61f78"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga4ddfc9953eb0e009c773f60a75a61f78">direct_netcdf_mod::read_transpose_multi_task</a> (state_ens_handle, name_handle, domain, dart_index, read_var_by_var)</td></tr>
<tr class="memdesc:ga4ddfc9953eb0e009c773f60a75a61f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in variables from model restart file and transpose so that every processor has all copies of a subset of state variables (fill state_ens_handlecopies) Read and transpose data according to the memory limit imposed by read_var_by_var.  <br /></td></tr>
<tr class="separator:ga4ddfc9953eb0e009c773f60a75a61f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac697410acb3e6e9c9483c6865694799" id="r_gaac697410acb3e6e9c9483c6865694799"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gaac697410acb3e6e9c9483c6865694799">direct_netcdf_mod::transpose_write_multi_task</a> (state_ens_handle, name_handle, domain, dart_index, write_var_by_var, write_single_precision)</td></tr>
<tr class="memdesc:gaac697410acb3e6e9c9483c6865694799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose from state_ens_handlecopies to the writers according to the memory limit imposed by write_var_by_var.  <br /></td></tr>
<tr class="separator:gaac697410acb3e6e9c9483c6865694799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285ec6a4e531cbba343a349a20deea76" id="r_ga285ec6a4e531cbba343a349a20deea76"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga285ec6a4e531cbba343a349a20deea76">direct_netcdf_mod::clamp_variable</a> (dom_id, var_index, variable)</td></tr>
<tr class="memdesc:ga285ec6a4e531cbba343a349a20deea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a variable for out of bounds and clamp or fail if needed. If the variable has clamping limits, this routine returns .TRUE. If the variable is unbounded, this routine returns .FALSE. The return value is not an indication of whether or not the values have actually been modified.  <br /></td></tr>
<tr class="separator:ga285ec6a4e531cbba343a349a20deea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4797f5013f67a845fdd1ac9aee5bdd9a" id="r_ga4797f5013f67a845fdd1ac9aee5bdd9a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga4797f5013f67a845fdd1ac9aee5bdd9a">direct_netcdf_mod::write_variables</a> (ncid, var_block, start_var, end_var, domain, do_file_clamping, force_copy)</td></tr>
<tr class="memdesc:ga4797f5013f67a845fdd1ac9aee5bdd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write variables from start_var to end_var no clamping.  <br /></td></tr>
<tr class="separator:ga4797f5013f67a845fdd1ac9aee5bdd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e5e10d0b1bbc7e42a16ee50f75906f" id="r_ga30e5e10d0b1bbc7e42a16ee50f75906f"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga30e5e10d0b1bbc7e42a16ee50f75906f">direct_netcdf_mod::create_and_open_state_output</a> (name_handle, dom_id, copy_number, dart_time, single_precision_output)</td></tr>
<tr class="memdesc:ga30e5e10d0b1bbc7e42a16ee50f75906f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write variables from start_var to end_var for actual ensemble members.  <br /></td></tr>
<tr class="separator:ga30e5e10d0b1bbc7e42a16ee50f75906f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga507c64d98551df97643e9e549a1e3a6d" id="r_ga507c64d98551df97643e9e549a1e3a6d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga507c64d98551df97643e9e549a1e3a6d">direct_netcdf_mod::write_variable_attributes</a> (filename, ncfileid, ncvarid, domid, varid, name_handle, copy_number)</td></tr>
<tr class="memdesc:ga507c64d98551df97643e9e549a1e3a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write model attributes if they exist. This is only used for files that are created by DART.  <br /></td></tr>
<tr class="separator:ga507c64d98551df97643e9e549a1e3a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4b6fd124b574282fccbff0d7c07437" id="r_ga9b4b6fd124b574282fccbff0d7c07437"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga9b4b6fd124b574282fccbff0d7c07437">direct_netcdf_mod::nc_write_file_information</a> (ncfileid, filename, description)</td></tr>
<tr class="memdesc:ga9b4b6fd124b574282fccbff0d7c07437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write global clamping attributes to files that already exist.  <br /></td></tr>
<tr class="separator:ga9b4b6fd124b574282fccbff0d7c07437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f849b5b89663f36e43ba4058555515" id="r_ga09f849b5b89663f36e43ba4058555515"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga09f849b5b89663f36e43ba4058555515">direct_netcdf_mod::nc_write_variable_att_clamping</a> (ncfileid, filename, ncvarid, domid, varid)</td></tr>
<tr class="memdesc:ga09f849b5b89663f36e43ba4058555515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write clamping to variable attributes to files created from scratch.  <br /></td></tr>
<tr class="separator:ga09f849b5b89663f36e43ba4058555515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f0ad63f26920f56019fe2036506b71" id="r_ga14f0ad63f26920f56019fe2036506b71"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga14f0ad63f26920f56019fe2036506b71">direct_netcdf_mod::nc_write_global_att_clamping</a> (ncfileid, copy, domid, from_scratch)</td></tr>
<tr class="memdesc:ga14f0ad63f26920f56019fe2036506b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write global clamping attributes for variables that have clamping.  <br /></td></tr>
<tr class="separator:ga14f0ad63f26920f56019fe2036506b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d438fbf74476572922b31434f3f2e9" id="r_gaf8d438fbf74476572922b31434f3f2e9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gaf8d438fbf74476572922b31434f3f2e9">direct_netcdf_mod::nc_write_revision_info</a> (ncfileid)</td></tr>
<tr class="memdesc:gaf8d438fbf74476572922b31434f3f2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write revision information.  <br /></td></tr>
<tr class="separator:gaf8d438fbf74476572922b31434f3f2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a4fb44801f712976ce12f96ac367f2" id="r_ga85a4fb44801f712976ce12f96ac367f2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga85a4fb44801f712976ce12f96ac367f2">direct_netcdf_mod::nc_write_missing_value_int</a> (ncfileid, filename, ncvarid, domid, varid)</td></tr>
<tr class="memdesc:ga85a4fb44801f712976ce12f96ac367f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write model integer missing_value/_FillValue attributes if they exist.  <br /></td></tr>
<tr class="separator:ga85a4fb44801f712976ce12f96ac367f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97512c742d614257d5013e176e85a3a9" id="r_ga97512c742d614257d5013e176e85a3a9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga97512c742d614257d5013e176e85a3a9">direct_netcdf_mod::nc_write_missing_value_r4</a> (ncfileid, filename, ncvarid, domid, varid)</td></tr>
<tr class="memdesc:ga97512c742d614257d5013e176e85a3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write model r4 missing_value/_FillValue attributes if they exist.  <br /></td></tr>
<tr class="separator:ga97512c742d614257d5013e176e85a3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad501af477a3530059fd8cac992d89632" id="r_gad501af477a3530059fd8cac992d89632"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gad501af477a3530059fd8cac992d89632">direct_netcdf_mod::nc_write_missing_value_r8</a> (ncfileid, filename, ncvarid, domid, varid)</td></tr>
<tr class="memdesc:gad501af477a3530059fd8cac992d89632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write model r8 missing_value/_FillValue attributes if they exist.  <br /></td></tr>
<tr class="separator:gad501af477a3530059fd8cac992d89632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637259129bab7191a953fc685b83b23f" id="r_ga637259129bab7191a953fc685b83b23f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga637259129bab7191a953fc685b83b23f">direct_netcdf_mod::get_pe_loops</a> (ens_size, recv_start, recv_end, send_start, send_end)</td></tr>
<tr class="memdesc:ga637259129bab7191a953fc685b83b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pes for loop indices if you have M tasks and N ensemble members, only the first N + extra copy tasks will send, everyone will receive.  <br /></td></tr>
<tr class="separator:ga637259129bab7191a953fc685b83b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f365fad4bff8aeef537b79fa8c65c6" id="r_gad4f365fad4bff8aeef537b79fa8c65c6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gad4f365fad4bff8aeef537b79fa8c65c6">direct_netcdf_mod::send_to_waiting_task</a> (state_ens_handle, recv_pe, start, elm_count, block_size, variable_block)</td></tr>
<tr class="memdesc:gad4f365fad4bff8aeef537b79fa8c65c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send elements of variables to a processor. This routine must be called with a corresponding 'wait_to_receive'. The data on the sender are non-contiguous with a stride of task_count. The start is different depending on which pe is the recv and which variables are being sent (these are calculated in the calling routine). The data on the receiver are contiguous (it is the copies array)  <br /></td></tr>
<tr class="separator:gad4f365fad4bff8aeef537b79fa8c65c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb9423c2f193aec26e71a63aa6496d3" id="r_gadcb9423c2f193aec26e71a63aa6496d3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gadcb9423c2f193aec26e71a63aa6496d3">direct_netcdf_mod::send_variables_to_write</a> (state_ens_handle, recv_pe, ensemble_member, start, finish)</td></tr>
<tr class="memdesc:gadcb9423c2f193aec26e71a63aa6496d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data from a pe to a writer. Note this may be 1 variable or many. Start is the start index in copies on the sending pe. Finish is the last index in copies to send. If all variables are transposed at once, start = 1, finish = ens_handlemy_num_vars (on sending pe) This routine must be called with a corresponding 'recv_variables_to_write.' The data on the sender is non-contiguous since it is a ROW of copies.  <br /></td></tr>
<tr class="separator:gadcb9423c2f193aec26e71a63aa6496d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0931795ec7b987d9782e4998a62b51" id="r_ga7b0931795ec7b987d9782e4998a62b51"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga7b0931795ec7b987d9782e4998a62b51">direct_netcdf_mod::wait_to_receive</a> (state_ens_handle, recv_pe, ensemble_member, start, finish)</td></tr>
<tr class="memdesc:ga7b0931795ec7b987d9782e4998a62b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from a reader. Start and finish are the local indicies in the copies array for the data being received. If all variables are transposed at once, start = 1, finish = ens_handlemy_num_vars (on receiveing pe) This routine must be called with a corresponding 'send_to_waiting_task'. The data on the sender is non-contiguous since it is a ROW of copies.  <br /></td></tr>
<tr class="separator:ga7b0931795ec7b987d9782e4998a62b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53c53011a55614fac307142233b83d4" id="r_gab53c53011a55614fac307142233b83d4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gab53c53011a55614fac307142233b83d4">direct_netcdf_mod::recv_variables_to_write</a> (state_ens_handle, sending_pe, start, elm_count, block_size, variable_block)</td></tr>
<tr class="memdesc:gab53c53011a55614fac307142233b83d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data to write/collect. The data is put non-contiguously into variable_block. Variable_block is the block of data writen to a netcdf file. It may be 1 or more variables. start and elm_count depend on the sending pe. These are calculated in the calling code. The stride is task_count() since we are assuming a round robin distribution of state vector onto processors. This routine must be called with a corresponding 'send_variables_to_write'.  <br /></td></tr>
<tr class="separator:gab53c53011a55614fac307142233b83d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9832acfa2d0a5df09bb4a312efa0d407" id="r_ga9832acfa2d0a5df09bb4a312efa0d407"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga9832acfa2d0a5df09bb4a312efa0d407">direct_netcdf_mod::write_model_variables</a> (ncfileid, model_state, memindex, curr_ens_time, timeindex)</td></tr>
<tr class="memdesc:ga9832acfa2d0a5df09bb4a312efa0d407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write state to the last time slice of a file when using "single file io".  <br /></td></tr>
<tr class="separator:ga9832acfa2d0a5df09bb4a312efa0d407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490370b86f88f566fa0e84c367401b0a" id="r_ga490370b86f88f566fa0e84c367401b0a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga490370b86f88f566fa0e84c367401b0a">direct_netcdf_mod::write_model_attributes</a> (ncfileid, member_dimid, time_dimid, file_handle)</td></tr>
<tr class="memdesc:ga490370b86f88f566fa0e84c367401b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write model attributes to for each variable when using "single file io".  <br /></td></tr>
<tr class="separator:ga490370b86f88f566fa0e84c367401b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7ae906009b2de66351c7a1bb904987" id="r_ga1b7ae906009b2de66351c7a1bb904987"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga1b7ae906009b2de66351c7a1bb904987">direct_netcdf_mod::write_extra_variables</a> (ncfileid, model_state, copyname, curr_ens_time, timeindex)</td></tr>
<tr class="memdesc:ga1b7ae906009b2de66351c7a1bb904987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out extra copies (if specified in the filter_nml) in the last time slot. This is only used for the when writting single file diagnostc/restart files.  <br /></td></tr>
<tr class="separator:ga1b7ae906009b2de66351c7a1bb904987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06dc065665c83c091c1b4c4feb5c16b8" id="r_ga06dc065665c83c091c1b4c4feb5c16b8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga06dc065665c83c091c1b4c4feb5c16b8">direct_netcdf_mod::write_extra_attributes</a> (ncfileid, time_dimid, file_handle, copy_index)</td></tr>
<tr class="memdesc:ga06dc065665c83c091c1b4c4feb5c16b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out extra copies (if specified in the filter_nml) attribute in the last time slot. This is only used when writting single file diagnostc/restart files.  <br /></td></tr>
<tr class="separator:ga06dc065665c83c091c1b4c4feb5c16b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac25ed7ba0ea54f5ac988274990c2f955" id="r_gac25ed7ba0ea54f5ac988274990c2f955"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gac25ed7ba0ea54f5ac988274990c2f955">direct_netcdf_mod::get_dimension_info</a> (copy, dom_id, var_id, timestep, is_extra, numdims, start, lengths)</td></tr>
<tr class="memdesc:gac25ed7ba0ea54f5ac988274990c2f955"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to return the netcdf dimension id's and lengths  <br /></td></tr>
<tr class="separator:gac25ed7ba0ea54f5ac988274990c2f955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ebb0777e5db14d4e6915b13b652b23" id="r_ga13ebb0777e5db14d4e6915b13b652b23"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga13ebb0777e5db14d4e6915b13b652b23">direct_netcdf_mod::check_singlefile_member_info</a> (ncid, fname, ens_size, do_pert)</td></tr>
<tr class="memdesc:ga13ebb0777e5db14d4e6915b13b652b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">we're in read_single_file - there better be multiple members or we can't read in an ensemble from this file. the only exception is if we are reading in a single member to perturb into an ensemble. otherwise it's an error.  <br /></td></tr>
<tr class="separator:ga13ebb0777e5db14d4e6915b13b652b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0254908b100e01af1a9f26cc4685bf76" id="r_ga0254908b100e01af1a9f26cc4685bf76"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga0254908b100e01af1a9f26cc4685bf76">direct_netcdf_mod::nc_get_tindex</a> (ncfileid, statetime)</td></tr>
<tr class="memdesc:ga0254908b100e01af1a9f26cc4685bf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">We need to compare the time of the current assim_model to the netcdf time coordinate variable (the unlimited dimension). If they are the same, no problem ... If it is earlier, we need to find the right index and insert ... If it is the "future", we need to add another one ... If it is in the past but does not match any we have, we're in trouble. The new length of the "time" variable is returned.  <br /></td></tr>
<tr class="separator:ga0254908b100e01af1a9f26cc4685bf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9dc061f4e03f757d1ead8be309c5a28" id="r_gad9dc061f4e03f757d1ead8be309c5a28"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gad9dc061f4e03f757d1ead8be309c5a28">direct_netcdf_mod::nc_append_time</a> (ncfileid, dart_time)</td></tr>
<tr class="memdesc:gad9dc061f4e03f757d1ead8be309c5a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current time is appended to the "time" coordinate variable. The new length of the "time" variable is returned.  <br /></td></tr>
<tr class="separator:gad9dc061f4e03f757d1ead8be309c5a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31098fc0ee34f4559645cd5122edc81e" id="r_ga31098fc0ee34f4559645cd5122edc81e"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga31098fc0ee34f4559645cd5122edc81e">direct_netcdf_mod::nc_write_calendar_atts</a> (ncfileid, timevarid)</td></tr>
<tr class="memdesc:ga31098fc0ee34f4559645cd5122edc81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">routine write calendar attributes  <br /></td></tr>
<tr class="separator:ga31098fc0ee34f4559645cd5122edc81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb7b451fc6de3f86bffb169fa700f668" id="r_gafb7b451fc6de3f86bffb169fa700f668"><td class="memItemLeft" align="right" valign="top">integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gafb7b451fc6de3f86bffb169fa700f668">direct_netcdf_mod::nc_get_num_times</a> (fname)</td></tr>
<tr class="separator:gafb7b451fc6de3f86bffb169fa700f668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de05cb71d2bbee35200331c64f5a4c5" id="r_ga6de05cb71d2bbee35200331c64f5a4c5"><td class="memItemLeft" align="right" valign="top">integer(i8) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga6de05cb71d2bbee35200331c64f5a4c5">direct_netcdf_mod::num_elements_on_pe</a> (pe, start_rank, block_size)</td></tr>
<tr class="memdesc:ga6de05cb71d2bbee35200331c64f5a4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate number of elements going to the receiving pe (read_transpose) Or being sent from the sending pe (transpose_write) for a given start_rank and block_size. block_size is the number of elements in a block of variables. There may be 1 variable or all variables depending on buffer_state_io. start_rank is the pe that owns the 1st element of the 1st variable in the variable_block.  <br /></td></tr>
<tr class="separator:ga6de05cb71d2bbee35200331c64f5a4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac406bea6ff4528072fe75da92c522693" id="r_gac406bea6ff4528072fe75da92c522693"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gac406bea6ff4528072fe75da92c522693">direct_netcdf_mod::get_start_rank</a> (variable, domain)</td></tr>
<tr class="memdesc:gac406bea6ff4528072fe75da92c522693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the rank of the processor that owns the start of a variable.  <br /></td></tr>
<tr class="separator:gac406bea6ff4528072fe75da92c522693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806acc05ff4f8aaa9db2906f9df08c47" id="r_ga806acc05ff4f8aaa9db2906f9df08c47"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga806acc05ff4f8aaa9db2906f9df08c47">direct_netcdf_mod::find_start_point</a> (recv_pe, start_rank)</td></tr>
<tr class="memdesc:ga806acc05ff4f8aaa9db2906f9df08c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find i, the start point in var_block for a given recv_pe This is assuming round robin. - will have to query the ensemble manager to find this for different disrtibutions.  <br /></td></tr>
<tr class="separator:ga806acc05ff4f8aaa9db2906f9df08c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfe0a8ae9bd2d3677457afeeb15226e" id="r_ga5cfe0a8ae9bd2d3677457afeeb15226e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga5cfe0a8ae9bd2d3677457afeeb15226e">direct_netcdf_mod::set_dart_missing_value</a> (array, domain, variable)</td></tr>
<tr class="memdesc:ga5cfe0a8ae9bd2d3677457afeeb15226e"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace the netCDF missing_value or _FillValue with the DART missing value.  <br /></td></tr>
<tr class="separator:ga5cfe0a8ae9bd2d3677457afeeb15226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a5d51284ae8bd115186ab8e168a574" id="r_ga31a5d51284ae8bd115186ab8e168a574"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga31a5d51284ae8bd115186ab8e168a574">direct_netcdf_mod::set_model_missing_value</a> (array, domain, variable)</td></tr>
<tr class="memdesc:ga31a5d51284ae8bd115186ab8e168a574"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace the DART missing value code with the original netCDF missing_value (or _FillValue) value.  <br /></td></tr>
<tr class="separator:ga31a5d51284ae8bd115186ab8e168a574"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad476696086fa805d73d50f68486f59cc" id="r_ad476696086fa805d73d50f68486f59cc"><td class="memItemLeft" align="right" valign="top">character(len= *), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedirect__netcdf__mod.html#ad476696086fa805d73d50f68486f59cc">direct_netcdf_mod::source</a> = 'direct_netcdf_mod.f90'</td></tr>
<tr class="separator:ad476696086fa805d73d50f68486f59cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8747a4cc552d1e203e04d48d72ae3269" id="r_ga8747a4cc552d1e203e04d48d72ae3269"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga8747a4cc552d1e203e04d48d72ae3269">direct_netcdf_mod::single_io_task_id</a> = 0</td></tr>
<tr class="separator:ga8747a4cc552d1e203e04d48d72ae3269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1afe8e546cf04d71faf60750393aaa9f" id="r_ga1afe8e546cf04d71faf60750393aaa9f"><td class="memItemLeft" align="right" valign="top">integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga1afe8e546cf04d71faf60750393aaa9f">direct_netcdf_mod::ret</a></td></tr>
<tr class="separator:ga1afe8e546cf04d71faf60750393aaa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9895fa2d5184a06d7e067817bc46895" id="r_gaf9895fa2d5184a06d7e067817bc46895"><td class="memItemLeft" align="right" valign="top">character(len=512)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#gaf9895fa2d5184a06d7e067817bc46895">direct_netcdf_mod::msgstring</a></td></tr>
<tr class="separator:gaf9895fa2d5184a06d7e067817bc46895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee9f8782a2aebda59b8b20a45537673" id="r_ga0ee9f8782a2aebda59b8b20a45537673"><td class="memItemLeft" align="right" valign="top">character(len=512)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga0ee9f8782a2aebda59b8b20a45537673">direct_netcdf_mod::msgstring2</a></td></tr>
<tr class="separator:ga0ee9f8782a2aebda59b8b20a45537673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537d935ffe862c59c53c24dc4825ec14" id="r_ga537d935ffe862c59c53c24dc4825ec14"><td class="memItemLeft" align="right" valign="top">logical&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__direct__netcdf__mod.html#ga537d935ffe862c59c53c24dc4825ec14">direct_netcdf_mod::overwrite_time_in_output_file</a> = .false.</td></tr>
<tr class="separator:ga537d935ffe862c59c53c24dc4825ec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
